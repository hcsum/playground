<h1>i18n solution in shared UI component</h1>
<p>On the partner central reservation deposits page, there is a section displaying the default cancellation policy, which is a shared UI component published on NPM. In this case, the project <code>epc-reservation-deposit-web</code> is the consumer of the shared UI component <code>epc-cancelpolicy-ui</code> . </p>
<p><img src="i18n-cp-section.png" referrerpolicy="no-referrer" alt="2021-04-21 at 10.36 AM"></p>
<p>In <code>epc-reservation-deposit-web</code> we use the component like so,</p>
<pre><code class='language-tsx' lang='tsx'>import { CancelPolicyNote } from &#39;epc-cancelpolicy-ui&#39;

function ParentComponent() {
  return (
    &lt;div className=&quot;default-cancel-policy&quot;&gt;
      &lt;CancelPolicyNote htid={propertyId} /&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>This is convenient but comes with a caveat. All i18n files for this piece of UI live in the component. Take a look on epc-reservation-deposit-web&#39;s bundle analysis, <strong>All i18n files are bundled together. This means even the client only needs to display one language, it will force the user to download all 34 files:</strong> </p>
<p><img src="i18n-before-op.png" referrerpolicy="no-referrer" alt="2021-04-01 at 5.30 PM"></p>
<p>In a typical server-client app, the server knows the user&#39;s locale when the request comes in and can pick the i18n file in use, generate a script to write the strings to the <code>Window</code> object,  where the client can read from.</p>
<p>But in terms of shared UI component, there is no way for the component to know beforehand which i18n file to use, thus all the 34 files are bundled in the component.</p>
<p>The consumer could have extracted all i18n files in the shared UI component, move them to the server and treat them as its own. This will solve the problem but this means the consumer need to do extra work to use this UI component instead of a simple install-and-import. </p>
<h2>Dynamic import comes to resecue</h2>
<p>Webpack supports code-splitting by dynamic import. We can configure <code>epc-cancelpolicy-ui</code>&#39;s babel to compile all ESNext syntax except <code>esmodule</code> syntax:</p>
<pre><code class='language-json' lang='json'>// .babelrc
{
  &quot;presets&quot;: [
    [
      &quot;@babel/preset-env&quot;,
      {
        &quot;modules&quot;: false
      }
    ],
    ...
  ]
}
</code></pre>
<p>This way, as the author of the shared UI component, we are assuming the consumers of our component will use a bundler such as Webpack which supports <code>esmodule</code> syntax to further compile the code. </p>
<p>Next, we add this function to the UI component: </p>
<pre><code class='language-typescript' lang='typescript'>const getMessageSource = () =&gt; {
  const locale = window?.EPC?.i18n?.locale || &quot;en_US&quot;;
  const javaLocale = getJavaLocale(locale);

  return import(
		`../i18n/messages_${javaLocale}.json`
  )
    .then((source) =&gt; {
      const i18nCXL = {
        i18n: {
          messages: source.default
        },
      };
      window.EPC = merge(window.EPC, i18nCXL);
    })
    .catch((err) =&gt; {
  		// error handling
    });
};
</code></pre>
<p>We first get the current locale from <code>window</code>, then we dynamically import the corresponding i18n file and write to <code>window</code> object mimicking what the script generated by the server does. </p>
<p>And use this function like so:</p>
<pre><code class='language-tsx' lang='tsx'>import getMessageSource from &quot;./getMessageSource&quot;;

interface IProps {
  htid: number;
}

const CancelPolicyNote: FC&lt;IProps&gt; = ({ htid }: IProps) =&gt; {
	getMessageSource()

  return (
    &lt;ApolloProvider client={client}&gt;
      &lt;ContentWrap htid={htid} /&gt;
    &lt;/ApolloProvider&gt;
  );
};
</code></pre>
<p>Look at <code>epc-reservation-deposit-web</code> &#39;s bundle analysis again, all i18n files are in their separate chunks: </p>
<p><img src="i18n-4.png" referrerpolicy="no-referrer" alt="2021-04-01 at 5.57 PM"></p>
<p>How awesome is this! Webpack splits the i18n files into their own chunk. Now if the consumer uses our shared component, the initial bundle will not contain any i18n files. And the one i18n file that actually needed will be downloaded at run time based on the user&#39;s locale. </p>
<h2><code>import()</code>is an async function</h2>
<p>If we load the page again, it will look like this, the i18n key for the word &quot;Loading&quot; is displayed instead of the actual text:</p>
<p><img src="i18n-lockey.png" referrerpolicy="no-referrer" alt="i18n-lockey"> </p>
<p>This is because i18n file is downloading the same time React is rendering. If the file is not downloaded before loading state is finished, even the actual content will be i18n key only.</p>
<p>To avoid this, we can wrap our <code>getMessageSource</code> function with a simple custom react hook:</p>
<pre><code class='language-tsx' lang='tsx'>const useMessageSource = () =&gt; {
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() =&gt; {
    getMessageSource().then(() =&gt; setIsLoaded(true));
  }, []);

  return isLoaded;
};
</code></pre>
<p>And use the hook in our component like so:</p>
<pre><code class='language-tsx' lang='tsx'>const CancelPolicyNote: FC&lt;IProps&gt; = ({ htid }: IProps) =&gt; {
  const isMessageSourceLoaded = useMessageSource();

  if (!isMessageSourceLoaded) return null;

  return (
    &lt;ApolloProvider client={client}&gt;
      &lt;ContentWrap htid={htid} /&gt;
    &lt;/ApolloProvider&gt;
  );
};
</code></pre>
<p>Now we will ensure React won&#39;t render the actual content of the component before the i18n file is ready. </p>
<p><img src="i18n-5.png" referrerpolicy="no-referrer" alt="i18n-5"></p>
<h2>That is all</h2>
<p>Lodash has a version called lodash-es, <a href='https://www.npmjs.com/package/lodash-es' target='_blank' class='url'>https://www.npmjs.com/package/lodash-es</a>, the approach is the same, to leverage Webpack&#39;s code splitting for dynamic import.</p>
